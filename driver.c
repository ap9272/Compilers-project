/*
 Batch number: 36
 Pratik Satish (2013A7PS057P)
 Anurag Prakash (2013A7PS061P)
*/
 
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#include"helperfunctions.h"
#include"firstfollow.h"
#include"lexer.h"
#include"parser.h"
#include"symbolTable.h"
#include"typechecker.h"
#include"semanticAnalysis.h"
#include"codeGen.h"

extern char * buff, * block;
extern FILE * fp;
extern int counter;

int syntactic_error,symboltable_error,typechecker_error,semanticanalysis_error;

int getPTreeSize(ParseTreeNode *ptNode)
{
	int sum = 0;
	ParseTreeNode *children = ptNode->child;
	while(children != NULL)
	{
		sum += getPTreeSize(children);
		children = children->sibling;
	}

	return 1 + sum;
}

int getASTSize(ParseTreeNode *ptNode)
{
	int sum = 0;
	ParseTreeNode *children = ptNode->child;
	if(children==NULL){
		return 0;
	}
	while(children != NULL)
	{
		sum += getASTSize(children);
		children = children->sibling;
	}

	return 1 + sum;
}


int main(int argc, char *argv[])
{
	if(argc != 3)
	{
		printf("Error: run program in this format : ./toycompiler testcase.txt code.asm ");
		return 1;
	}

	int i,j;
	read_grammer("given_rules.txt");

	int T[no_of_non_terminals][no_of_terminals];

	for (i = 0; i < no_of_non_terminals; ++i)
	{
		for (j = 0; j < no_of_terminals; ++j)
		{
			T[i][j] = -1;
		}
	}

	int choice;
	ParseTreeNode *PT = NULL;
	symbolTable *ST = NULL;

	printf("*******************************************\n");
	printf("LEVEL 4: Symbol table/ AST/ Type checking/ Semantic Rules/ Code generation modules work.\n");
	printf("*******************************************\n");
	printf("Give your choice\n");
	printf("1. For printing the token list (on the console) generated by the lexer.\n");
	printf("2. For parsing to verify the syntactic correctness of the input source code and produce Parse Tree on the console.\n");
	printf("3. For printing Abstract Syntax tree on console.\n");
	printf("4. For diplaying amount of allocated memory and no of nodes to each parse tree and ast.\n");
	printf("5. For creating symbol table.\n");
	printf("6. For compiling to verify the syntactic and semantic correctness of input source code.\n");
	printf("7. For producing assembly code.\n");
	printf("8. Exit.\n");
	printf("Your choice : ");
	scanf(" %d", &choice);

	switch(choice)
	{
		case 1:
				printf("Printing tokenlist :\n");
				FILE *temp_open = fopen(argv[1], "ra");
				if(fseek(temp_open, -1, SEEK_END) == 0)
				{
					if(fgetc(temp_open) == '\n')
					{
						fclose(temp_open);
					}
					else
					{
						fputc('\n',temp_open);
						fclose(temp_open);	
					}
				}
				fp=fopen (argv[1], "rb");
				tokenlist *temp = (tokenlist *)malloc(sizeof(tokenlist));
				bytesread = -1;
				block=(char *)malloc(1024);
				buff=(char *)malloc(1024);
				temp=getNextToken(block,temp);
				while(temp->t.tokenName[0] != '\0')
				{
					printf("%s, %s, %d\n", temp->t.tokenName, temp->t.lexeme, temp->lineno);
					temp=getNextToken(block,temp);
				}

				fclose(fp);
				break;
		case 2:
				for (i = 0; i < no_of_non_terminals; ++i)
				{
					for (j = 0; j < no_of_terminals; ++j)
					{
						T[i][j] = -1;
					}
				}
				PT = NULL;
				createParseTable(rules, T);
				PT = parseInputSourceCode(argv[1], T);
				printParseTree(PT, "abcd");
				break;
		case 3:
				for (i = 0; i < no_of_non_terminals; ++i)
				{
					for (j = 0; j < no_of_terminals; ++j)
					{
						T[i][j] = -1;
					}
				}
				PT = NULL;
				createParseTable(rules, T);
				PT = parseInputSourceCode(argv[1], T);
				// printf("syntactic error : %d\n", syntactic_error);
				createAST(PT);
				printParseTree(PT, "abcd");
				PT = NULL;
				break;
		case 4:
				for (i = 0; i < no_of_non_terminals; ++i)
				{
					for (j = 0; j < no_of_terminals; ++j)
					{
						T[i][j] = -1;
					}
				}
				PT = NULL;
				createParseTable(rules, T);
				PT = parseInputSourceCode(argv[1], T);
				int noOfPnodes=getPTreeSize(PT);

				printf("Parse Tree\tNumber of Nodes = %d\tAllocated Memory = %d Bytes\n",  noOfPnodes,(int)sizeof(ParseTreeNode)*noOfPnodes);

				createAST(PT);
				int noOfAnodes = getASTSize(PT);
				printf("AST\tNumber of Nodes = %d\tAllocated Memory = %d Bytes\n",  noOfAnodes,(int)sizeof(ParseTreeNode)*noOfAnodes);

				printf("Compression percentage = %f\n", ((float)(noOfPnodes-noOfAnodes)/noOfPnodes)*100 );

				break;
		case 5:
				//symbolTable *ST;
				PT = NULL;
				createParseTable(rules, T);
				PT = parseInputSourceCode(argv[1], T);
				if(syntactic_error)
				{
					printf("The given code contains syntactic error. Could not generate symbol table.\n");
					break;
				}
				createAST(PT);					
				ST = fillSymbolTable(PT, 100);
				printf("Symbol table created\n");
				printSymbolTable(ST);
				typeCheck(PT);
				PT = NULL;
				break;
		case 6:
				PT = NULL;
				createParseTable(rules, T);
				PT = parseInputSourceCode(argv[1], T);
				if(syntactic_error)
				{
					printf("The given code contains syntactic error. Could not verify semantic correctness.\n");
					break;
				}
				createAST(PT);					
				ST = fillSymbolTable(PT, 100);
				if(symboltable_error)
				{
					printf("The given code contains symbol table error. Could not verify type correctness.\n");
					break;
				}
				typeCheck(PT);
				if(typechecker_error)
				{
					printf("The given code contains type error. Could not verify other semantic correctness.\n");
					break;
				}
				semanticAnalysis(PT);
				if(semanticanalysis_error)
				{
					printf("The given code contains semantic errors. Not compiled properly.\n");
					break;
				}
				printf("Code compiled successfully.\n");
				break;
		case 7:
				PT = NULL;
				createParseTable(rules, T);
				PT = parseInputSourceCode(argv[1], T);
				if(syntactic_error)
				{
					printf("The given code contains syntactic error. Could not verify semantic correctness.\n");
					break;
				}
				createAST(PT);					
				ST = fillSymbolTable(PT, 100);
				if(symboltable_error)
				{
					printf("The given code contains symbol table error. Could not verify type correctness.\n");
					break;
				}
				typeCheck(PT);
				if(typechecker_error)
				{
					printf("The given code contains type error. Could not verify other semantic correctness.\n");
					break;
				}
				semanticAnalysis(PT);
				if(semanticanalysis_error)
				{
					printf("The given code contains semantic errors. Not compiled properly.\n");
					break;
				}
				printf("Code compiled successfully.\n");
				FILE *codefile = fopen(argv[2],"w");
				fprintf(codefile,"extern printf\nextern scanf\nSECTION .data\n");
				codegen(PT, codefile);

				fprintf(codefile, "mov ebx,0\n");
				fprintf(codefile, "mov eax,1\n");
				fprintf(codefile, "int 80h\n");

				fclose(codefile);
				printf("ASM file created.\n");
				break;
		default:
		printf("%d\n", choice);
				printf("Goodbyee\n");
	}

	return 0;
}